<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Corson N. Areshenkoff">
<meta name="dcterms.date" content="2024-03-11">

<title>Synergizing reinforcement learning with functional deep quantum neural manifold learning – areshenkBlog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">areshenkBlog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../packages.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/areshenk"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Synergizing reinforcement learning with functional deep quantum neural manifold learning</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Corson N. Areshenkoff </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 11, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>It’s been more than a few years since I’ve actually played around with any gambling tasks, and in the intervening time, models of sequential decision making based on concepts from quantum mechanics were briefly in vogue in several journals devoted to decision making and learning. I haven’t studied any quantum mechanics in a while, either, so I thought it would be interesting to unpack one of these models: Specifically, the model of Iowa Gambling Task performance reported by <span class="citation" data-cites="li2020quantum">Li et al. (<a href="#ref-li2020quantum" role="doc-biblioref">2020</a>)</span>, which claims to find better fits to Human performance than classical models, such as ones based on the delta learning rule.</p>
<p>I admit I’m largely ignorant of most of these models’ uses in the literature. There do seem to be cases where quantum and classical models produce measurably different predictions, and in where quantum models appear to explain patterns of preference judgement not captured by classical models <span class="citation" data-cites="epping2023using">(e.g. <a href="#ref-epping2023using" role="doc-biblioref">Epping and Busemeyer 2023</a>)</span>; but the cynic in me wonders if a large part of the appeal isn’t the quantum language itself, especially as descriptions of these models in the literature tend to bury the reader in notation without providing insight.</p>
<p>In this case, the problem to solve is a standard Iowa gambling task (IGT), which is just a four-armed bandit disguised as a card game. On each trial, subjects are presented with four decks of cards, and upon choosing one, receives a monetary reward. The rewards associated with each deck are probabilistic, and the subject is told to earn as much money as possible by the end of the task, and must do so by selecting from each deck and learning which of the four is the most profitable.</p>
<p>A standard model for this task looks something like this: The subject maintains a valuation <span class="math inline">\(v = (v_1,v_2,v_3,v_4)\)</span>, which encodes something like the expected utility for each deck. Upon choosing a card <span class="math inline">\(i\)</span>, the subject receives a payout <span class="math inline">\(x\)</span>, which has utility <span class="math inline">\(u(x)\)</span>. The subject then updates the valuation for deck <span class="math inline">\(i\)</span> according to some update rule, and chooses another card with probability computed by passing <span class="math inline">\(v\)</span> through a softmax function. Typically, the utility function and update rules depend on subject-specific parameters encoding e.g.&nbsp;learning rate, loss aversion, etc., and these parameters are estimated from subjects’ performance in order to draw inference about the subject’s decision making strategy <span class="citation" data-cites="steingroever2013comparison">(see e.g. <a href="#ref-steingroever2013comparison" role="doc-biblioref">Steingroever, Wetzels, and Wagenmakers 2013</a> for a taxonomy of similar models)</span>.</p>
<p>Now, onto the quantum model. Let’s dispense with the quantum mechanical formalism, and especially with the quantum mechanical <em>notation</em>, which is needlessly opaque for anyone outside of the field. In finite dimensions (the only case anyone ever actually considers in these applications), nothing happens that can’t be more concisely written using standard matrix notation; and so we’ll treat this as an ordinary model of sequential decision making with a weird update rule, and we’ll use standard linear algebraic notation.</p>
<p>Assume that the subject maintains a valuation <span class="math inline">\(z(t) = (z_1,z_2,z_3,z_4)\)</span> for each deck on trial <span class="math inline">\(t\)</span>, where at this point the only notable departure is that <span class="math inline">\(z\)</span> is a vector of complex numbers. After selecting deck <span class="math inline">\(i\)</span>, they observe an outcome with utility <span class="math inline">\(u\)</span>. The update rule is slightly complex, so we’ll proceed in steps. Ultimately, we’ll define a matrix <span class="math inline">\(G\)</span> so that the valuation on the next trial is</p>
<p><span class="math display">\[
  z(t+1) = Gz(t),
\]</span> so that, fundamentally, we’re just working with a linear update.</p>
<p>The matrix <span class="math inline">\(G\)</span> (which we’ll call the Grover matrix) is decomposed into a pair of matrices <span class="math inline">\(G = U_2U_1\)</span> which depend, respectively, on the chosen deck and on the current valuation <span class="math inline">\(z(t)\)</span>. Letting <span class="math inline">\(z\)</span> be the current valuation and letting <span class="math inline">\(a\)</span> be an indicator vector for the chosen deck (i.e.&nbsp;if deck <span class="math inline">\(i\)</span> was chosen, the <span class="math inline">\(i\)</span>’th entry is 1, and the rest are zero), they are defined as follows:</p>
<p><span class="math display">\[\begin{align*}
  U_1 &amp;= I - (1 - e^{i\psi_1})aa^{\top} \\
  U_2 &amp;= (1 - e^{i\psi_2})zz^{\top} - I
\end{align*}\]</span> where <span class="math inline">\(I\)</span> is the identity matrix.</p>
<p>To be very explicit, for those uncomfortable working with complex numbers, the notation <span class="math inline">\(e^{i\psi_1}\)</span> denotes the complex number <span class="math inline">\(cos(\psi_1) + isin(\psi_1)\)</span>, and the transpose <span class="math inline">\(z^\top\)</span> always denotes the <em>conjugate</em> transpose (i.e.&nbsp;an entry <span class="math inline">\(a+bi\)</span> becomes <span class="math inline">\(a-bi\)</span>). To be even more explicit:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ComputeGrover <span class="ot">&lt;-</span> <span class="cf">function</span>(psi, a, z) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ndecks <span class="ot">&lt;-</span> <span class="fu">length</span>(a)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  I  <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">complex</span>(ndecks, <span class="at">real =</span> <span class="dv">1</span>, <span class="at">imaginary =</span> <span class="dv">0</span>))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  e1 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">complex</span>(<span class="at">modulus =</span> <span class="dv">1</span>, <span class="at">argument =</span> psi[<span class="dv">1</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  e2 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">complex</span>(<span class="at">modulus =</span> <span class="dv">1</span>, <span class="at">argument =</span> psi[<span class="dv">2</span>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  U1 <span class="ot">&lt;-</span> I <span class="sc">-</span> e1 <span class="sc">*</span> (a <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">Conj</span>(a)))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  U2 <span class="ot">&lt;-</span> e2 <span class="sc">*</span> (z <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">Conj</span>(z))) <span class="sc">-</span> I</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(U2 <span class="sc">%*%</span> U1)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The only thing that remains is to define <span class="math inline">\((\psi_1,\psi_2)\)</span>. The authors define the quantities as a function of the utility <span class="math inline">\(u\)</span>:</p>
<p><span class="math display">\[\begin{align*}
  \psi_1 &amp;= \pi (u \cos(\pi \eta) + b_1) \\
  \psi_2 &amp;= \pi (u \sin(\pi \eta) + b_2),
\end{align*}\]</span> where <span class="math inline">\((\eta, b_1, b_2)\)</span> are parameters (but see the discussion below). Again, to be explicit:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ComputePsi <span class="ot">&lt;-</span> <span class="cf">function</span>(u, pars) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  eta <span class="ot">&lt;-</span> pars<span class="sc">$</span>eta</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  b1  <span class="ot">&lt;-</span> pars<span class="sc">$</span>b1</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  b2  <span class="ot">&lt;-</span> pars<span class="sc">$</span>b2</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  psi <span class="ot">&lt;-</span> <span class="fu">c</span>(pi <span class="sc">*</span> (u <span class="sc">*</span> <span class="fu">cos</span>(pi<span class="sc">*</span>eta) <span class="sc">+</span> b1),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>           pi <span class="sc">*</span> (u <span class="sc">*</span> <span class="fu">sin</span>(pi<span class="sc">*</span>eta) <span class="sc">+</span> b2))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(psi)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once we have the updated valuations <span class="math inline">\(z\)</span>, the probability of selecting deck <span class="math inline">\(i\)</span> is the squared modulus <span class="math inline">\(|z_i|^2\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ComputeChoiceProbs <span class="ot">&lt;-</span> <span class="cf">function</span>(z) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Mod</span>(z)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Complexity aside, what I want to make clear here is that, however the update rule was derived, ultimately we are just fitting curves to subjects’ behavior. In particular, the snippets of code that I’ve provided will implement this learning rule on your very own, boring, non-quantum computer. Using this model, your stupid classical laptop will succeed in learning a Bandit task like the IGT, even though it has never even seen Oppenheimer and nothing “quantum” is happening in the way your CPU manipulates bits in memory. This is, first and foremost, a flexible curve-fitting algorithm.</p>
<section id="intuition" class="level3">
<h3 class="anchored" data-anchor-id="intuition">Intuition</h3>
<p>Consider the more straightforward update of the delta learning rule, where the subject maintains a valuation <span class="math inline">\(x = (x_1,x_2,x_3,x_4)\)</span> denoting the expected utility of each deck, and updates the valuation of the chosen deck <span class="math inline">\(x_i\)</span> according to</p>
<p><span class="math display">\[
  x_i(t+1) = x_i(t) + k[u - x_i(t)].
\]</span></p>
<p>That is, if the observed utility was higher than expected, we update our expectation upward; and vice versa. The actual <em>mechanism</em> underlying the update of our quantum learning rule is much more opaque, but we can get some geometric intuition.</p>
<p>Suppose our current valuation of the four decks is <span class="math inline">\(z(t) = (z_1,z_2,z_3,z_4)\)</span>, and so the probability that we choose deck <span class="math inline">\(i\)</span> is <span class="math inline">\(|z_i|^2\)</span>. This implies that <span class="math inline">\(\sum_{i=1}^4 |z_i|^2 = 1\)</span>, and so <span class="math inline">\(z\)</span> is a unit vector lying on a sphere. The norm <span class="math inline">\(|z_i|\)</span> is just the projection of <span class="math inline">\(z\)</span> onto the <span class="math inline">\(i\)</span>-axis, and so the probability that we select this deck is roughly proportional to how much <span class="math inline">\(z\)</span> points in the direction of the corresponding deck.</p>
<p>This is easiest to see in the simple two-dimensional example in the figure below, where we imagine two decks <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and a (real-valued) valuation <span class="math inline">\(z = (z_1,z_2)\)</span>. Here, the (square of the norm of the) projections of <span class="math inline">\(z\)</span> onto the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>-axes determine the probabilities of the respective deck selections.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/quantsphere.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>Note that, however we update <span class="math inline">\(z\)</span> after observing the outcome of our selection, the new valuation <span class="math inline">\(z'\)</span> must <em>also</em> lie on the sphere, and so can be obtained by applying a rotation to <span class="math inline">\(z\)</span> about the origin. Sensibly, we would like to rotate <span class="math inline">\(z\)</span> to point “more towards” the chosen deck if it payed well. Intuitively, this is a perfectly sensible learning rule.</p>
<p>This is, in fact, precisely what is happening. The matrices <span class="math inline">\(U_1\)</span> and <span class="math inline">\(U_2\)</span> are unitary transformations, and so in particular are simply rotations (and reflections) about the origin. Assuming our axes</p>
<p><span class="math display">\[\begin{align*}
  a_1 &amp;= (1,0,0,0) \\
  a_2 &amp;= (0,1,0,0) \\
  a_3 &amp;= (0,0,1,0) \\
  a_4 &amp;= (0,0,0,1)
\end{align*}\]</span></p>
<p>correspond to the four respective decks, we would like the result of applying <span class="math inline">\(G = U_2U_1\)</span> to be a rotation/reflection of <span class="math inline">\(z\)</span> to point more parallel to or more orthogonal to the chosen deck, depending on whether the outcome was better or worse than expected, respectively.</p>
<p>Through a rather elaborate derivation, the authors give the ratio <span class="math inline">\(R\)</span> of this change in probability (that is, the ratio of the probability of deck <span class="math inline">\(a\)</span> before and after having observed the outcome with utility <span class="math inline">\(u\)</span>):</p>
<p><span class="math display">\[
  R = \left |(1 - e^{i\psi_1} - e^{i\psi_2}) - (1 - e^{i\psi_1})(1 - e^{i\psi_2})|z_a|^2 \right |^2
\]</span> This closed-form update is especially useful, as it let’s us directly visualize some unusual model behavior.</p>
</section>
<section id="what-does-the-update-look-like" class="level3">
<h3 class="anchored" data-anchor-id="what-does-the-update-look-like">What does the update look like?</h3>
<p>Now, here’s the point of this exercise. We’ll consider two models in parallel, which we’ll call QM (for quantum model) and CM (classical model). Both will use the same utility, but QM will apply the update we’ve just discussed, while CM will use the delta learning rule along with a softmax function to determine deck selection probabilities.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">CM</th>
<th style="text-align: left;">QM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valuation</td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{R}\)</span>-valued</td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{C}\)</span>-valued</td>
</tr>
<tr class="even">
<td>Update</td>
<td style="text-align: left;"><span class="math inline">\(z_i(t+1) = z_i(t) + r[u - z_i(t)]\)</span></td>
<td style="text-align: left;"><span class="math inline">\(Gz(t)\)</span></td>
</tr>
<tr class="odd">
<td>Selection</td>
<td style="text-align: left;"><span class="math inline">\(P(k) = \frac{e^{z_k}}{\sum_{i=1}^4 e^{z_i}}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(P(k) = |z_k|^2\)</span></td>
</tr>
<tr class="even">
<td>Initial valuations</td>
<td style="text-align: left;"><span class="math inline">\(z_k = 0\)</span></td>
<td style="text-align: left;"><span class="math inline">\(z_k = \frac{1}{2} + 0i\)</span></td>
</tr>
</tbody>
</table>
<p>This is what we’re going to do: We’re going to pick deck (say, deck 1) and look at the change in selection probability for that deck as a function of the utility. Specifically, since we have a closed-form expression for this for the QM model, we’ll be comparing the log-odds of selecting the deck before and after the outcome, as a function of the model parameters. Here is it for the model CM:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/cm_logodds.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>Note that this is completely sensible. As the utility increases, our probability of selecting the deck increases as the utility of the outcome increases, and this effect is greater for higher learning rates <span class="math inline">\(r\)</span>.</p>
<p>Now onto the, uh…difficulty of model QM. First things first, we’ll ignore the parametrization in terms of <span class="math inline">\(u\)</span>, and just focus on the log-odds of selecting the chosen deck as a function of <span class="math inline">\((\psi_1,\psi_2)\)</span>, however they are calculated. Note that, as these are angles, they are periodic with period <span class="math inline">\(2\pi\)</span>, and so it suffices to consider only this range.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>For clarity, the red region corresponds to values of <span class="math inline">\((\psi_1,\psi_2)\)</span> leading to an increased probability of selecting the chosen deck, and vice versa for the blue. What we <em>want</em> to do is define some continuous function <span class="math inline">\(f\)</span> which maps the observed utility (maybe depending on some parameters) to some value of <span class="math inline">\((\psi_1,\psi_2)\)</span>. And we would like to do this in a way that we end up in the red region if the utility is positive, and in the blue region otherwise. Note that we specify <em>continuous</em> because would expect similar utilities to result in similar updates. If this function has parameters, we would also like them to be <em>interpretable</em>, in the way that <span class="math inline">\(r\)</span> in the delta learning rule can clearly be interpreted as the learning rate.</p>
<p>As the authors point out, the mapping</p>
<span class="math display">\[\begin{align*}
  \psi_1(u; \eta, b_1, b_2) &amp;= \pi (u \cos(\pi \eta) + b_1) \\
  \psi_2(u; \eta, b_1, b_2) &amp;= \pi (u \sin(\pi \eta) + b_2),
\end{align*}\]</span>
<p>defines a line passing through the point <span class="math inline">\((b_1,b_2)\)</span>, with slope <span class="math inline">\(\tan(\pi \eta)\)</span>. Intuitively, the mapping <span class="math inline">\(G\)</span> defines a surface mapping the <span class="math inline">\((\psi_1,\psi_2)\)</span> to the change in deck selection probability, and <span class="math inline">\((\psi_1,\psi_2)_{\eta,b_1,b_2}\)</span> maps the observed utility to a one-dimension slice of this space, as depicted below. Note that, despite what the plot below indicates (as I don’t have the energy to correct it), the “center” of this line (corresponding to zero utility) is at the point <span class="math inline">\((\pi b_1, \pi b_2)\)</span>.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot_pars.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>There are two things I dislike about this parametrization as a model for Human behavior. First, the parameters are extremely difficult to interpret, as the relationship between utility and the change in deck probability are very difficult to read from the parameter values themselves. If the user knows the landscape of the function, they can compute the effect of zero utility by looking at whether the update implied by <span class="math inline">\((\pi b_1, \pi b_2)\)</span> is positive or negative, but the effect of <span class="math inline">\(\eta\)</span> in particular is entirely dependent on the basepoint <span class="math inline">\((b_1,b_2)\)</span>, and can imply opposite things about the effect of increasing utility depending on the specific values.</p>
<p>The second is that, because the log-odds are periodic in <span class="math inline">\((\psi_1,\psi_2)\)</span>, any unbounded function of <span class="math inline">\(u\)</span> (such as this one) will exhibit oscillatory behavior, as shown in the example below:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot_wonkypars.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>We can see this exactly by choosing some specific parameters – say, <span class="math inline">\((\eta, b_1, b_2) = (0.1, .9, .7)\)</span>. Then, here are the log-odds for different utilities:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>Actually, we can be more specific. As the update is periodic in both <span class="math inline">\(\psi_1\)</span> and <span class="math inline">\(\psi_1\)</span>, the parameter space of <span class="math inline">\(G\)</span> is actually a torus (seen below).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/torusplot.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>The parametrization of the update in terms of (<span class="math inline">\(\eta, b_1, b_2\)</span>) means that the change in log-odds is the orbit of a linear flow, which immediately suggests some odd behavior. For one, for any rational <span class="math inline">\(\eta\)</span>, the orbit is a closed curve, and so the update is periodic in the observed utility. This means that the model cannot increase its preference for a deck monotonically with the increasing utility: If a small negative utility results in a decrease in deck preference, then a large enough <em>positive</em> utility must also result in a decrease in preference. I’m not sure if it’s realistic to expect that people learn this way. In fact, the global model behavior seem obviously inconsistent with the way that people actually learn.</p>
<p>I suspect that, for a specific payoff schedule, it would be possible to carefully tailor the parameters so that the log-odds over the range of experienced utility lies in a well behaved region of the space. For example, if the utility experienced by the subject is constrained within <span class="math inline">\((-.2, .5)\)</span>, then the parameters <span class="math inline">\((\eta, b_1, b_2) = (0.1, 0, .5)\)</span> give a reasonable update:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>For these specific values of <span class="math inline">\((b_1, b_2)\)</span>, the parameter <span class="math inline">\(\eta\)</span> is almost interpretable as something like an inverse learning rate:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>In fact, we get a pretty close approximation of the curves generated by the CM for different learning rate parameters. But not so for slightly different values <span class="math inline">\((b_1, b_2) = (-.2, .3)\)</span>:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example4.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>Now, <span class="math inline">\(\eta\)</span> is hardly interpretable at all. For positive values, all utilities near zero result in a <em>decreased</em> selection probability, while negative values gives an almost-sensible but non-monotonic change in probability. In this sense, the model is <em>extremely</em> flexible for a relatively small number of parameters (only one additional parameter compared to something like the PVL-delta), at the cost of the parameters being nearly uninterpretable from a cognitive or behavioral standpoint, arguably negating the primary use of these models in psychology and neuroscience.</p>
<p>When we dispense with the quantum language and view it merely as a model of sequential decision making with a particularly flexible policy update, the structure of the model is quite simple: We have a smooth surface – a function of <span class="math inline">\((\psi_1,\psi_2)\)</span> – and we take a slice of this surface by defining a line in the plane (a function of <span class="math inline">\(\eta\)</span>, <span class="math inline">\(b_1\)</span>, and <span class="math inline">\(b_2\)</span>). This slice gives the change in log-odds of selection as a function of the observed utility. Since the surface is reasonably complex, we can get a wide variety of these probability curves depending on where we place the line; hence the flexibility of the model.</p>
<p>As a model, it’s interesting, but since it is fundamentally just curve fitting, and since the weird oscillatory learning behavior is clearly inconsistent with the way decision making is likely to be implemented in the brain, I’m not sure that the model’s performance really suggests that the brain is leveraging “quantum” phenomena. Shor’s algorithm is a polynomial time quantum algorithm for integer factorization. And yet, we wouldn’t claim that the ability of a subject to factor small numbers in their head is evidence for some kind of quantum computation in the brain. Classical algorithms can do prime factorization too. Quantum algorithms are designed to take advantage of the architecture of a quantum computer, but they typically solve the same <em>problems</em>. The mere fact that a model based on quantum computation can predict behavior (e.g.&nbsp;the <em>output</em> of some computation) does not, by itself, suggest any kind of quantum computation in the brain unless we can also show that something in the computational architecture of the brain is actually quantized.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-epping2023using" class="csl-entry" role="listitem">
Epping, Gunnar P, and Jerome R Busemeyer. 2023. <span>“Using Diverging Predictions from Classical and Quantum Models to Dissociate Between Categorization Systems.”</span> <em>Journal of Mathematical Psychology</em> 112: 102738.
</div>
<div id="ref-li2020quantum" class="csl-entry" role="listitem">
Li, Ji-An, Daoyi Dong, Zhengde Wei, Ying Liu, Yu Pan, Franco Nori, and Xiaochu Zhang. 2020. <span>“Quantum Reinforcement Learning During Human Decision-Making.”</span> <em>Nature Human Behaviour</em> 4 (3): 294–307.
</div>
<div id="ref-steingroever2013comparison" class="csl-entry" role="listitem">
Steingroever, Helen, Ruud Wetzels, and Eric-Jan Wagenmakers. 2013. <span>“A Comparison of Reinforcement Learning Models for the Iowa Gambling Task Using Parameter Space Partitioning.”</span> <em>The Journal of Problem Solving</em> 5 (2): 2.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>