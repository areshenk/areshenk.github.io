<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Corson N. Areshenkoff">
<meta name="dcterms.date" content="2024-01-11">

<title>areshenkBlog - Maximizing cognitive synergy with functional deep quantum neural manifold learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">areshenkBlog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../research.html" rel="" target="">
 <span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html" rel="" target="">
 <span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../packages.html" rel="" target="">
 <span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/areshenk" rel="" target=""><i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Maximizing cognitive synergy with functional deep quantum neural manifold learning</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Corson N. Areshenkoff </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 11, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>It’s been more than a few years since I’ve actually played around with any gambling tasks, but I do so</p>
<p>Decision making and reinforcement learning seem to be the most popular applications of quantum modelling in the behavioural or neural sciences, possibly because the analogy between uncertainty and the quantum superposition of different possible responses is just too tempting. Or something.</p>
<p>That doesn’t mean that models inspired by quantum mechanics are inherently bad, they can sometimes be quite interesting: Here’s an example.</p>
<p>Let’s dispense with the quantum mechanical formalism, and especially with the quantum mechanical <em>notation</em>, which is needlessly opaque for anyone outside of the field. In finite dimensions (the only case anyone ever actually considers in these applications), nothing happens that can’t be more concisely written using standard matrix notation; and so we’ll treat this as an ordinary model of sequential decision making with a weird update rule, and we’ll use standard linear algebraic notation.</p>
<p>Assume that the subject maintains a valuation <span class="math inline">\(z(t) = (z_1,z_2,z_3,z_4)\)</span> for each deck on trial <span class="math inline">\(t\)</span>, where at this point the only notable departure is that <span class="math inline">\(z\)</span> is a vector of complex numbers. After selecting deck <span class="math inline">\(i\)</span>, they observe an outcome with utility <span class="math inline">\(u\)</span>. The update rule is slightly complex, so we’ll proceed in steps. Ultimately, we’ll define a matrix <span class="math inline">\(G\)</span> so that the valuation on the next trial is</p>
<p><span class="math display">\[
  z(t+1) = Gz(t),
\]</span> so that, fundamentally, we’re just working with a linear update.</p>
<p>The matrix <span class="math inline">\(G\)</span> (which we’ll call the Grover matrix) is decomposed into a pair of matrices <span class="math inline">\(G = U_2U_1\)</span> which depend, respectively, on the chosen deck and on the current valuation <span class="math inline">\(z(t)\)</span>. Letting <span class="math inline">\(z\)</span> be the current valuation and letting <span class="math inline">\(a\)</span> be an indicator vector for the chosen deck (i.e.&nbsp;if deck <span class="math inline">\(i\)</span> was chosen, the <span class="math inline">\(i\)</span>’th entry is 1, and the rest are zero), they are defined as follows:</p>
<p><span class="math display">\[\begin{align*}
  U_1 &amp;= I - (1 - e^{i\psi_1})aa^{\top} \\
  U_2 &amp;= (1 - e^{i\psi_2})zz^{\top} - I
\end{align*}\]</span> where <span class="math inline">\(I\)</span> is the identity matrix.</p>
<p>To be very explicit, for those uncomfortable working with complex numbers, the notation <span class="math inline">\(e^{i\psi_1}\)</span> denotes the complex number <span class="math inline">\(cos(\psi_1) + isin(\psi_1)\)</span>, and the transpose <span class="math inline">\(z^\top\)</span> always denotes the <em>conjugate</em> transpose (i.e.&nbsp;an entry <span class="math inline">\(a+bi\)</span> becomes <span class="math inline">\(a-bi\)</span>). To be even more explicit:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ComputeGrover <span class="ot">&lt;-</span> <span class="cf">function</span>(psi, a, z) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ndecks <span class="ot">&lt;-</span> <span class="fu">length</span>(a)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  I  <span class="ot">&lt;-</span> <span class="fu">diag</span>(<span class="fu">complex</span>(ndecks, <span class="at">real =</span> <span class="dv">1</span>, <span class="at">imaginary =</span> <span class="dv">0</span>))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  e1 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">complex</span>(<span class="at">modulus =</span> <span class="dv">1</span>, <span class="at">argument =</span> psi[<span class="dv">1</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  e2 <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">complex</span>(<span class="at">modulus =</span> <span class="dv">1</span>, <span class="at">argument =</span> psi[<span class="dv">2</span>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  U1 <span class="ot">&lt;-</span> I <span class="sc">-</span> e1 <span class="sc">*</span> (a <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">Conj</span>(a)))</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  U2 <span class="ot">&lt;-</span> e2 <span class="sc">*</span> (z <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">Conj</span>(z))) <span class="sc">-</span> I</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(U2 <span class="sc">%*%</span> U1)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The only thing that remains is to define <span class="math inline">\((\psi_1,\psi_2)\)</span>. The authors define the quantities as a function of the utility <span class="math inline">\(u\)</span>:</p>
<p><span class="math display">\[\begin{align*}
  \psi_1 &amp;= \pi (u \cos(\pi \eta) + b_1) \\
  \psi_2 &amp;= \pi (u \sin(\pi \eta) + b_2),
\end{align*}\]</span> where <span class="math inline">\((\eta, b_1, b_2)\)</span> are parameters (but see the discussion below). Again, to be explicit:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ComputePsi <span class="ot">&lt;-</span> <span class="cf">function</span>(u, pars) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  eta <span class="ot">&lt;-</span> pars<span class="sc">$</span>eta</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  b1  <span class="ot">&lt;-</span> pars<span class="sc">$</span>b1</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  b2  <span class="ot">&lt;-</span> pars<span class="sc">$</span>b2</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  psi <span class="ot">&lt;-</span> <span class="fu">c</span>(pi <span class="sc">*</span> (u <span class="sc">*</span> <span class="fu">cos</span>(pi<span class="sc">*</span>eta) <span class="sc">+</span> b1),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>           pi <span class="sc">*</span> (u <span class="sc">*</span> <span class="fu">sin</span>(pi<span class="sc">*</span>eta) <span class="sc">+</span> b2))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(psi)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once we have the updated valuations <span class="math inline">\(z\)</span>, the probability of selecting deck <span class="math inline">\(i\)</span> is the squared modulus <span class="math inline">\(|z_i|^2\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ComputeChoiceProbs <span class="ot">&lt;-</span> <span class="cf">function</span>(z) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Mod</span>(z)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Complexity aside, what I want to make clear here is that, however the update rule was derived, ultimately we are just fitting curves to subjects’ behaviour. In particular, the snippets of code that I’ve provided will implement this learning rule on your very own, boring, non-quantum computer. Using this model, your stupid classical laptop will succeed in learning a Bandit task like the IGT, even though it has never even seen Oppenheimer and nothing “quantum” is happening in the way your CPU manipulates bits in memory. This is, first and foremost, a flexible curve-fitting algorithm.</p>
<section id="intuition" class="level3">
<h3 class="anchored" data-anchor-id="intuition">Intuition</h3>
<p>Consider the more straightforward update of the delta learning rule, where the subject maintains a valuation <span class="math inline">\(x = (x_1,x_2,x_3,x_4)\)</span> denoting the expected utility of each deck, and updates the valuation of the chosen deck <span class="math inline">\(x_i\)</span> according to</p>
<p><span class="math display">\[
  x_i(t+1) = x_i(t) + k[u - x_i(t)].
\]</span> That is, if the observed utility was higher than expected, we update our expectation upward; and vice versa. The actual <em>mechanism</em> underlying the update of our quantum learning rule is much more opaque, but we can get some geometric intuition.</p>
<p>Suppose our current valuation of the four decks is <span class="math inline">\(z(t) = (z_1,z_2,z_3,z_4)\)</span>, and so the probability that we choose deck <span class="math inline">\(i\)</span> is <span class="math inline">\(|z_i|^2\)</span>. This implies that <span class="math inline">\(\sum_{i=1}^4 |z_i|^2 = 1\)</span>, and so <span class="math inline">\(z\)</span> is a unit vector lying on a sphere. The norm <span class="math inline">\(|z_i|\)</span> is just the projection of <span class="math inline">\(z\)</span> onto the <span class="math inline">\(i\)</span>-axis, and so the probability that we select this deck is roughly proportional to how much <span class="math inline">\(z\)</span> points in the direction of the corresponding deck.</p>
<p>This is easiest to see in the simple two-dimensional example in the figure below, where we imagine two decks <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and a (real-valued) valuation <span class="math inline">\(z = (z_1,z_2)\)</span>. Here, the (square of the norm of the) projections of <span class="math inline">\(z\)</span> onto the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>-axes determine the probabilities of the respective deck selections.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/quantsphere.png" class="img-fluid figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>Note that, however we update <span class="math inline">\(z\)</span> after observing the outcome of our selection, the new valuation <span class="math inline">\(z'\)</span> must <em>also</em> lie on the sphere, and so can be obtained by applying a rotation to <span class="math inline">\(z\)</span> about the origin. Sensibly, we would like to rotate <span class="math inline">\(z\)</span> to point “more towards” the chosen deck if it payed well. Intuitively, this is a perfectly sensible learning rule.</p>
<p>This is, in fact, precisely what is happening. The matrices <span class="math inline">\(U_1\)</span> and <span class="math inline">\(U_2\)</span> are unitary transformations, and so in particular are simply rotations (and reflections) about the origin. Assuming our axes</p>
<p><span class="math display">\[\begin{align*}
  a_1 &amp;= (1,0,0,0) \\
  a_2 &amp;= (0,1,0,0) \\
  a_3 &amp;= (0,0,1,0) \\
  a_4 &amp;= (0,0,0,1)
\end{align*}\]</span> correspond to the four respective decks, we would like the result of applying <span class="math inline">\(G = U_2U_1\)</span> to be a rotation/reflection of <span class="math inline">\(z\)</span> to point more parallel to or more orthogonal to the chosen deck, depending on whether the outcome was better or worse than expected, respectively.</p>
<p>Conditional on the chosen deck <span class="math inline">\(a\)</span>, it is useful to consider the decomposition of <span class="math inline">\(z\)</span> into a component in the direction of <span class="math inline">\(a\)</span> (that is, <span class="math inline">\(z_a\)</span>), and a component orthogonal to <span class="math inline">\(a\)</span> (<span class="math inline">\(z_{\perp a}\)</span>). Note that, since <span class="math inline">\(aa^\top\)</span> is a projection onto the subspace spanned by <span class="math inline">\(a\)</span>, the operator <span class="math inline">\(U_1\)</span> has a particularly simple interpretation:</p>
<ul>
<li><p>As <span class="math inline">\(z_{\perp a}\)</span> is orthogonal to <span class="math inline">\(a\)</span>, its projection onto <span class="math inline">\(a\)</span> is zero, and so <span class="math inline">\(U_1z_{\perp a} = z_{\perp a}\)</span>. So <span class="math inline">\(U_1\)</span> leaves the component orthogonal to the chosen deck unchanged.</p></li>
<li><p>By contrast, <span class="math inline">\(U_1z_a = e^{i\psi}z_a\)</span>.</p></li>
</ul>
<p>And so the application of <span class="math inline">\(U_1\)</span> is a rotation of the <span class="math inline">\(a\)</span>’th component <span class="math inline">\(z\)</span>, which leaves it’s magnitude (and thus the probability of selecting any given deck) unchanged. So the magic must happen with <span class="math inline">\(U_2\)</span>. In particular, whatever <span class="math inline">\(U_2\)</span> does, it has to change the relative amplitude of <span class="math inline">\(z_a\)</span> and <span class="math inline">\(z_{\perp a}\)</span> (and thus the relative probability of choosing vs.&nbsp;not choosing deck <span class="math inline">\(a\)</span>). Through a rather elaborate derivation, the authors (CITE; see supplement) give the ratio <span class="math inline">\(R\)</span> of this change in probability (that is, the ratio of the probability of deck <span class="math inline">\(a\)</span> before and after having observed the outcome with utility <span class="math inline">\(u\)</span>):</p>
<p><span class="math display">\[
  R = \left |(1 - e^{i\psi_1} - e^{i\psi_2}) - (1 - e^{i\psi_1})(1 - e^{i\psi_2})|z_a|^2 \right |^2
\]</span></p>
</section>
<section id="what-does-the-update-look-like" class="level3">
<h3 class="anchored" data-anchor-id="what-does-the-update-look-like">What does the update look like?</h3>
<p>Now, here’s the point of this exercise. We’ll consider two models in parallel, which we’ll call QM (for quantum model) and CM (classical model). Both will use the same utility, but QM will apply the update we’ve just discussed, while CM will use the delta learning rule along with a softmax function to determine deck selection probabilities.</p>
<table class="table">
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">CM</th>
<th style="text-align: left;">QM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Valuation</td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{R}\)</span>-valued</td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{C}\)</span>-valued</td>
</tr>
<tr class="even">
<td>Update</td>
<td style="text-align: left;"><span class="math inline">\(z_i(t+1) = z_i(t) + r[u - z_i(t)]\)</span></td>
<td style="text-align: left;"><span class="math inline">\(Gz(t)\)</span></td>
</tr>
<tr class="odd">
<td>Selection</td>
<td style="text-align: left;"><span class="math inline">\(P(k) = \frac{e^{z_k}}{\sum_{i=1}^4 e^{z_i}}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(P(k) = |z_k|^2\)</span></td>
</tr>
<tr class="even">
<td>Initial valuations</td>
<td style="text-align: left;"><span class="math inline">\(z_k = 0\)</span></td>
<td style="text-align: left;"><span class="math inline">\(z_k = \frac{1}{2} + 0i\)</span></td>
</tr>
</tbody>
</table>
<p>This is what we’re going to do: We’re going to pick deck (say, deck 1) and look at the change in selection probability for that deck as a function of the utility. Specifically, since we have a closed-form expression for this for the QM model, we’ll be comparing the log-odds of selecting the deck before and after the outcome, as a function of the model parameters. Here is it for the model CM:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/cm_logodds.png" class="img-fluid figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>Note that this is completely sensible. As the utility increases, our probability of selecting the deck increases as the utility of the outcome increases, and this effect is greater for higher learning rates.</p>
<p>Now onto the, uh…difficulty of model QM. First things first, we’ll ignore the parametrization in terms of <span class="math inline">\(u\)</span>, and just focus on the log-odds of selecting the chosen deck as a function of <span class="math inline">\((\psi_1,\psi_2)\)</span>, however they are calculated. Note that, as these are angles, they are periodic with period <span class="math inline">\(2\pi\)</span>, and so it suffices to consider only this range.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot.png" class="img-fluid figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>For clarity, the red region corresponds to values of <span class="math inline">\((\psi_1,\psi_2)\)</span> leading to an increased probability of selecting the chosen deck, and vice versa for the blue. What we <em>want</em> to do is define some continuous function <span class="math inline">\(f\)</span> which maps the observed utility (maybe depending on some parameters) to some value of <span class="math inline">\((\psi_1,\psi_2)\)</span>. And we would like to do this in a way that we end up in the red region if the utility is positive, and in the blue region otherwise. Note that we specify <em>continuous</em> because would expect similar utilities to result in similar updates. If this function has parameters, we would also like them to be <em>interpretable</em>, in the way that <span class="math inline">\(r\)</span> in the delta learning rule can clearly be interpreted as the learning rate.</p>
<p>As the authors point out, the mapping</p>
<span class="math display">\[\begin{align*}
  \psi_1(u; \eta, b_1, b_2) &amp;= \pi (u \cos(\pi \eta) + b_1) \\
  \psi_2(u; \eta, b_1, b_2) &amp;= \pi (u \sin(\pi \eta) + b_2),
\end{align*}\]</span>
<p>defines a line passing through the point <span class="math inline">\((b_1,b_2)\)</span>, with slope <span class="math inline">\(\tan(\pi \eta)\)</span>. Intuitively, the mapping <span class="math inline">\(G\)</span> defines a surface mapping the observed utility to the change in deck selection probability, and <span class="math inline">\((\psi_1,\psi_2)_{\eta,b_1,b_2}\)</span> Specifically, despite what the plot below indicates (as I don’t have the energy to correct it), the “center” of this line (corresponding to zero utility) is at the point <span class="math inline">\((\pi b_1, \pi b_2)\)</span>.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot_pars.png" class="img-fluid figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>There are two things I dislike about this parametrization as a model for Human behaviour. First, the parameters are extremely difficult to interpret, as the relationship between utility and the change in deck probability are very difficult to read from the parameter values themselves. If the user knows the landscape of the function, they can compute the effect of zero utility by looking at whether the update implied by <span class="math inline">\((\pi b_1, \pi b_2)\)</span> is positive or negative, but the effect of <span class="math inline">\(\eta\)</span> in particular is entirely dependent on the basepoint <span class="math inline">\((b_1,b_2)\)</span>, and can imply opposite things about the effect of increasing utility depending on the specific values.</p>
<p>The second is that, because the log-odds are periodic in <span class="math inline">\((\psi_1,\psi_2)\)</span>, any unbounded function of <span class="math inline">\(u\)</span> (such as this one) will exhibit oscillatory behaviour, as shown in the example below:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_psiplot_wonkypars.png" class="img-fluid figure-img" style="width:40.0%"></p>
</figure>
</div>
</div>
</div>
<p>We can see this exactly by choosing some specific parameters – say, <span class="math inline">\((\eta, b_1, b_2) = (0.1, .9, .7)\)</span>. Then, here are the log-odds for different utilities:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>I suspect that, for a specific payoff schedule, it would be possible to carefully tailor the parameters so that the log-odds over the range of experienced utility lies in a well behaved region of the space. For example, if the utility experienced by the subject is constrained within <span class="math inline">\((-.2, .5)\)</span>, then the parameters <span class="math inline">\((\eta, b_1, b_2) = (0.1, 0, .5)\)</span> give a reasonable update:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example2.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>For these specific values of <span class="math inline">\((b_1, b_2)\)</span>, the parameter <span class="math inline">\(\eta\)</span> is almost interpretable as something like an inverse learning rate:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example3.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>In fact, we get a pretty close approximation of the curves generated by the CM for different learning rate parameters. But not so for slightly different values <span class="math inline">\((b_1, b_2) = (-.2, .3)\)</span>:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/qm_logodds_example4.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
</div>
</div>
<p>In this sense, the model is <em>extremely</em> flexible for a relatively small number of parameters (only one additional parameter compared to something like the PVL-delta), at the cost of 1) the parameters being nearly uninterpretable from a cognitive or behavioural standpoint; and 2) the brain almost certainly not actually learning in this way.</p>
<p>When we dispense with the quantum language and view it merely as a model of sequential decision making with a particularly flexible policy update, the components of the model actually have pretty interesting interpretation. The map <span class="math inline">\(G = U_2U_1\)</span> is effectively a</p>
<p>https://www.edmprod.com/wavetable-synthesis/</p>
<p>Shor’s algorithm is a polynomial time quantum algorithm for integer factorization. And yet, we wouldn’t claim that the ability of a subject to factor small numbers in their head is evidence for some kind of quantum computation in the brain. Classical algorithms can do prime factorization too. Quantum algorithms are designed to take advantage of the architecture of a quantum computer, but they typically solve the same <em>problems</em>. The mere fact that a model based on quantum computation can predict behaviour (e.g.&nbsp;the <em>output</em> of some computation) does not, by itself, suggest any kind of quantum computation in the brain unless we can also show that something in the computational architecture of the brain is actually quantized.</p>
<h3 class="anchored">
References
</h3>
<p style="margin-left: .5in; text-indent: -.5in;">
</p><p>Li, J. A., Dong, D., Wei, Z., Liu, Y., Pan, Y., Nori, F., &amp; Zhang, X. (2020). Quantum reinforcement learning during human decision-making. Nature human behaviour, 4(3), 294-307.</p>
<p></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>